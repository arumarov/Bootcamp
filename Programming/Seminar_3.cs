// Задача с прошлого семинара
// Попробуем оценить, какая из сортировок оптимальнее
void SortNumbers(int[] nums)
{
    int size = nums.Length;
    int[] temp = new int[nums.Length];

    for(int i = 0; i < size-1; i++)
    {
        for(int j = 0; j < size-1; j++)
        {
            if(temp[j]>temp[j+1])
            {
                int t = temp[j];
                temp[j] = temp[j+1];
                temp[j+1] = t;
            }
        }
    }

}

// Правила определения сложности алгоритмов:
//1. Если некоторой функции f(n) требуется n шагов, мы можем сказать, что сложность нашего алгоритма - О(n)
int a = 123; // 1 шаг
int b = 312; // 1 шаг
int c = a + b; // 1 шаг

int n = new Random().Next(1, 1000000);

for(int i = 0; i < n; i++)
{
    c =+ i; // n шагов
}

// 2. Если у нас есть какой-то код который зависит от n (например f(n)) 
// и еще код, который зависит от n (например g(n)), 
// то общая сложность определяется как сумма двух этих функций: f(n)+g(n)
int a = 123; // 1 шаг  f(1)
int b = 312; // 1 шаг  g(1)
int c = a + b; // 1 шаг + 1 шаг (отдельно сложение, отдельно присваивание)   h(2)
//                итого 4 шага

int n = new Random().Next(1, 1000000);

for(int i = 0; i < n; i++)
{
    c =+ i; // n шагов      k(n)
}
// f(n) + g(1) + h(2) + k(n)